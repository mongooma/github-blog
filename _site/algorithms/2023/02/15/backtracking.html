<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Writing Tree traversal for Backtracking &middot; Elapsed
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu:regular,bold&subset=Latin">

  <!-- JS -->
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <script src="https://code.jquery.com/jquery-3.3.0.min.js" integrity="sha256-RTQy8VOmNlT6b2PIRur37p6JEBZUE7o8wPgMvu18MC4=" crossorigin="anonymous"></script>
  <script src="/public/js/main.js"></script>

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">


</head>


  <body>

    


<div class="sidebar">
  <div class="sidebar-post-lead">
      <nav class="sidebar-nav-post-lead">
        <ul>
        </ul>
      </nav> 
  </div> 

  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Elapsed
        </a>
      </h1>
      <p class="lead">Mostly frameworks.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Recent</a>

      

      
      
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About Me</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/categories/">Categories</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/graphs/">On Graphs</a>
          
        
      
        
          
        
      

      <!-- <a class="sidebar-nav-item" href="/archive/v1.0.zip">Download</a> -->
      <!-- <a class="sidebar-nav-item" href="">GitHub project</a> -->
      <span class="sidebar-nav-item">Currently v1.0</span>
    </nav>

    <p>&copy; 2023. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <!-- <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script src="/public/js/main.js"></script> -->

<div class="post">
  <h1 class="post-title">Writing Tree traversal for Backtracking</h1>
  <span class="post-date">15 Feb 2023</span>  
  <section>
    <h2 id="backtracking-as-orderly-enumeration">Backtracking as orderly enumeration</h2>

<p>Backtracking searches all the possible solutions in the solution space in a systematic(orderly) way. It could provide an orderly enumeration for a general combination problem with constraint in the format:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>From a set S, choose a combination C from S.

Let this combination C satisfy g(C);
OR
Let this combination C satisfying g(C) achieve the best/max/min condition for a target function F(C).
</code></pre></div></div>

<p>To make the enumeration orderly, we could first construct the complete solution space from the orderly selection:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let S = {s1, s2, s3, ..., s_N}

Compose a combination C from:

Choosing c1 = s_1 -&gt; Choosing c2 from S - {c_1} -&gt; Choosing c3 from S - {c_1, c_2} -&gt; ...
</code></pre></div></div>
<p>This is useful when \(S\) is rather implicitly given, like in the subset-sum problems (e.g., Knapsack). But sometimes the \(S\) is not given explicitly, while the backtracking structure is more explicitly given already:</p>
<ul>
  <li>Board games (e.g., crossword, N-queen problem), where the nodes are the board positions, and the edges are transitions from a cell to its adjacent cells.</li>
  <li>Multi-player Step games (e.g., Decision-making min-max), where the nodes are the game states, and the edges are the choices/strategies taken by the player at the source node.</li>
  <li>Sequential-conditional select (e.g., Resource allocation problems (e.g. <a href="https://projecteuler.net/problem=151">PE151</a>)): where the nodes are the current states of the resources, and the edges are the decisions to make at this step.</li>
</ul>

<h2 id="the-dfs-traversal-structure-of-the-backtracking">The DFS traversal structure of the backtracking</h2>

<p>A backtracking structure is a path traversal in a tree/graph, where the nodes are the elements in the \(S\). 
Every candidate solution is a full path. 
For a graph representation, the fewer edges in the graph, the less complexity in the traversal toward the final solution. 
  The extreme trim-down of a graph is a tree, where the leaf nodes signify all the full paths from the root, and each should be considered and checked.</p>

<p>So even though backtracking is a searching method considering the entire search space, it would be more efficient than brute-force/full enumeration because we could prune the subtree of a node when we have decided no more exploration is necessary from a sub-solution.</p>

<h2 id="temporally-independent-dfs-search-paths">Temporally Independent DFS search paths</h2>

<p>Suppose we have already been given a tree of nodes and edges representing a problem. Backtracking is usually done by using depth-first-search as a subroutine.</p>

<p>From a node <code class="language-plaintext highlighter-rouge">n</code>, each search branch is a path down from this node. The search branches are temporally independent – if not done in parallel. So sometimes, it is convenient to utilize this temporal locality feature to assign temporary values to the visited edges and nodes. For example, in the crossword game, it requires that a word is composed of non-overlapping cells in the board.</p>

<p><img src="https://user-images.githubusercontent.com/3526618/219152451-34f8d8db-92cc-4099-a396-e0ad16adc7c6.png" alt="Tree Traversal and backtracking_temporalIndependent (1)" /></p>

<h2 id="objectprocedure-oriented-dfs">Object/Procedure-oriented DFS</h2>

<p>The search starting from the node <code class="language-plaintext highlighter-rouge">n</code> is done by calling <code class="language-plaintext highlighter-rouge">f(n)</code>. It’s often confusing as to what this function is actually doing. Basically, there are two ways to phrase it:</p>

<ul>
  <li>
    <p>The “object-oriented” way: We continue the search from <code class="language-plaintext highlighter-rouge">n</code> down the different branches, and return whether any search is a success from <code class="language-plaintext highlighter-rouge">n</code>.</p>
  </li>
  <li>
    <p>The “precedure-oriented” way: We walk from <code class="language-plaintext highlighter-rouge">n</code> and explore all the paths from this <code class="language-plaintext highlighter-rouge">n</code> with possible early stops.</p>
  </li>
</ul>

<p>The “object-oriented” way better describes the structure of the “root-tree/sub-trees and aggregation” search, which leads to –</p>

<h3 id="important-locality-feature-of-dfs-fn">Important Locality feature of DFS f(n)</h3>

<p><img src="https://user-images.githubusercontent.com/3526618/219152509-9dc4a19f-6141-4633-9174-019561d69f4b.png" alt="Tree Traversal and backtracking_aggregation" /></p>

<p>By writing <code class="language-plaintext highlighter-rouge">f(n, ...)</code> specifically for the the tree rooted on node <code class="language-plaintext highlighter-rouge">n</code>, it simultaneously implicates an important feature of <code class="language-plaintext highlighter-rouge">f(n, ...)</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">f(n, ...)</code> does not know anything about the subtrees besides that their root nodes are on the other end of the edges.</li>
</ul>

<p>That is:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">f(n, ...)</code> does not access the properties of the subtree root nodes <code class="language-plaintext highlighter-rouge">nbr</code>.</li>
</ul>

<h2 id="general-writing-style-of-fn-">General Writing Style of f(n, …)</h2>

<p>By incorporating the above rule, it follows the general writing style for <code class="language-plaintext highlighter-rouge">f(n)</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def f(n, state, params):
  if not continue_search(n): # no more branches from this node: node is None, some capacity limit is reached, state meets the termination, etc
    return ...

  res = []
  for nbr in n.neighbours:
    if nbr is valid:
      new_state &lt;- state_change(nbr, state) #state change based on choice of nbr
      new_params &lt;- param_change(params) #usually state unaware, e.g. level based
      res &lt;- f(nbr, new_state, params)

  return aggregate(res)

</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">aggregation()</code> above is a general way to get the solution for 
this node <code class="language-plaintext highlighter-rouge">n</code> from the subtrees. But sometimes if we only 
need to get one valid solution (“any”) instead of returning all applicable,
we could add the early break/return whenever we find a successful
<code class="language-plaintext highlighter-rouge">f(nbr, ...)</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def f(n, ...):
  ...
  for nbr in n.neighbours:
    if nbr is valid:
      ...
      if f(nbr, ...):
        return True

  return False

</code></pre></div></div>

<p>To remind ourselves at all time the locality of <code class="language-plaintext highlighter-rouge">f(n, ...)</code>, we could name it 
by the target function, like “found”, “matched”, “valid”, or the return type “max length”, 
“min cost”, etc.</p>

<h2 id="the-end-condition-for-fn-">The end condition for f(n, …)</h2>

<p>For different problems, it might require different writing styles for the end condition section in <code class="language-plaintext highlighter-rouge">f(n, ...)</code>.</p>

<p>For the <a href="https://leetcode.com/problems/word-search/">word matching problem</a>, the end condition is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def match(n, matched_word, remain_to_match, ...)
  if len(remain_to_match) == 0:
    return matched_word
</code></pre></div></div>

<p>For the <a href="https://leetcode.com/problems/n-queens/">N-queen problem</a>, the end condition is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def valid(pos, current_placements, ...):
  if len(current_placements) == N:
    return True
</code></pre></div></div>

<p>For a <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">binary tree max-depth problem</a>, the end condition is:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def maxDepth(root):
  if root is None:
    return 0
</code></pre></div></div>

<p><strong>Note for the binary tree:</strong></p>

<ul>
  <li>The end condition for <code class="language-plaintext highlighter-rouge">f(n)</code> when searching a binary tree is “when <code class="language-plaintext highlighter-rouge">n</code> is <code class="language-plaintext highlighter-rouge">None</code>”, but NOT “when <code class="language-plaintext highlighter-rouge">n</code> is a leaf node.”</li>
</ul>


  </section>

</div>

<div class="related">
  <h3>Most Recent Posts</h3>
  <ul class="related-posts">
    
      <li>
        <p>
          <a href="/project%20management/2023/02/18/PythonCrossFolderImport.html">
            Python: Cross-folder import
            <small>18 Feb 2023</small>
          </a>
        </p>
      </li>
    
      <li>
        <p>
          <a href="/maths/2023/02/09/geometric_sequence.html">
            Geometric Sequence Sum
            <small>09 Feb 2023</small>
          </a>
        </p>
      </li>
    
      <li>
        <p>
          <a href="/algorithms/2023/02/06/kosaraju.html">
            Illustration of Kosaraju's strongly connected components algorithm
            <small>06 Feb 2023</small>
          </a>
        </p>
      </li>
    
  </ul>
</div>


    </div>

  </body>
</html>
